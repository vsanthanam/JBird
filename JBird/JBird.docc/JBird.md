# ``JBird``

A blazing fast, type-safe library for working with JSON in Swift

## Overview

JBird provides a modern, Swift-first approach to JSON processing that eliminates the verbosity and type-casting chains common with Foundation's `JSONSerialization`. Built on a high-performance C11 parsing core, JBird offers both speed and safety through a comprehensive type system that represents JSON values as Swift enums.

The library is designed around the central `JSON` enum which safely represents all JSON value types: objects, arrays, strings, numbers, booleans, and null. This approach provides compile-time safety while maintaining runtime performance, making JSON manipulation both safer and more ergonomic.

## Features

JBird has a number of features. You can include them all in your project by importing the `JBird` module, or you can import individual features such as `JBirdCore` or `JBirdBuilders` individually if you are environment with binary size or build time constraints. See <doc:Setup> for more information on how to setup JBird in your Swift projects.

### A type-safe API to work with JSON in Swift

JBird's ``/JBirdCore/JSON`` enum eliminates unsafe type casting by representing each JSON value type explicitly. The enum conforms to Swift's `ExpressibleBy*Literal` protocols, allowing natural JSON construction using Swift's literal syntax. Each JSON value type is statically known, preventing runtime type errors and providing compile-time safety.

```swift
// Create JSON values using Swift literals
let nullValue: JSON = nil
let boolValue: JSON = true
let intValue: JSON = 42
let doubleValue: JSON = 3.14159
let stringValue: JSON = "Hello, world!"

// Create complex structures with literal syntax
let arrayValue: JSON = [1, "mixed", true, nil]
let objectValue: JSON = [
    "name": "Alice",
    "age": 30,
    "isActive": true,
    "scores": [95, 87, 92],
    "metadata": nil
]

// Type-safe access with throwing properties
let name = try objectValue["name"].stringValue
let age = try objectValue["age"].intValue
let isActive = try objectValue["isActive"].boolValue
```

For more information, see the ``/JBirdCore`` API reference, and the ``/JBirdCore/JSON`` symbol reference.

#### Composing JSON declaratively with result builders

Create JSON structures using Swift's result builder syntax with `ArrayBuilder` and `ObjectBuilder`. Build arrays and objects declaratively without manual dictionary or array construction. The `=>` operator provides clean key-value pair syntax for objects, while array builders support mixed-type elements naturally.

```swift
// Build JSON arrays declaratively
let jsonArray = JSON {
    "first item"
    42
    true
    ["nested": "object"]
}

// Build JSON objects with the => operator
let jsonObject = JSON {
    "name" => "John Doe"
    "age" => 30
    "isActive" => true
    "preferences" => JSON {
        "theme" => "dark"
        "notifications" => true
    }
    "tags" => JSON {
        "swift"
        "json"
        "performance"
    }
}
```

For more information, see the ``/JBirdBuilders`` API reference.

### Converting between typed JSON and other Swift types

JBird provides seamless conversion between `JSON` values and native Swift types through the `JSONCodable` protocol system. Built-in conformances cover all standard Swift types, while custom types can easily adopt the protocols for automatic conversion.

```swift
// Built-in type conversions
let json: JSON = ["name": "Alice", "age": 25, "scores": [95, 87, 92]]
let name: String = try json["name"].decode()
let age: Int = try json["age"].decode()
let scores: [Int] = try json["scores"].decode()

// Custom type conversion
struct User: JSONCodable {
    let name: String
    let age: Int
    let scores: [Int]
}

let user = try json.decode(into: User.self)
let backToJSON = JSON(user)
```

#### Using macros to easily support `JSONCodable` conformance

The `@JSONCodable` macro automatically generates encoding and decoding implementations for Swift types. Use `@JSONKey` to customize property names, `@OmitIfNil` to exclude nil values during encoding, and support for snake_case conversion. The macro system eliminates boilerplate while providing full control over the JSON representation.

```swift
@JSONCodable
struct User {
    let id: String
    @JSONKey("full_name") let name: String
    @JSONKey(.snakeCase) let firstName: String
    @OmitIfNil var nickname: String?
    let isActive: Bool
}

// Automatic encoding/decoding generated by macro
let user = User(id: "123", name: "John Doe", firstName: "John", nickname: nil, isActive: true)
let json = user.encodeToJSON()
let decoded = try User(json: json)
```

For more information, see the ``/JBirdMacros`` API reference.

### Blazing fast JSON serialization and deserialization

Built on a C11 parsing engine with SIMD acceleration, JBird delivers 2-5x faster parsing than SwiftyJSON and 25% faster than Foundation. The parser includes memory-efficient algorithms, configurable recursion limits, and strict RFC 8259 compliance. Both synchronous and asynchronous APIs support cancellation for large payloads.

For more information, see the ``/JBirdCore`` API reference.

## Topics

### Articles

- <doc:WhyJBird>
- <doc:Setup>

### API Reference

- ``/JBirdCore``
- ``/JBirdBuilders``
- ``/JBirdMacros``
